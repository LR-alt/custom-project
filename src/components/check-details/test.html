<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <script>
    const data = [
      {
        label: '详情1',
        grids: 5,
        children: [
          { prop: 'sub1' },
          {
            label: '详情1-2',
            children: [
              { label: '详情1-1-1', prop: 'tub1' },
              { label: '详情1-1-2', prop: 'tub2' },
            ]
          },
          { label: '详情1-3', prop: 'sub3' },
        ]
      },
      {
        label: '详情2',
        grids: 3,
        rowspan: 4,
        children: [
          { label: '详情2-1', prop: 'sub4', rowspan: 2 },
          { label: '详情2-2', prop: 'sub5', rowspan: 2 },
        ]
      },
    ]
    // merge data
    Object.assign(window, {
      formatColumns(columns) {
        const result = [];
        for (const items of columns) {
          const isNest = items.some((it) => it.children?.length);
          if (isNest) {
            //
          } else {
            const averageGrids = this.getAverageGrids(this.baseGrids, items);
            items.forEach((item, inx) => (item.colspan ||= averageGrids[inx]));
          }
        }
      },
      toFlat(item, grids = 8) {
        const result = [];
        const { label, children, rowspan } = item;
        let preLabel = null;

        if (label) {
          preLabel = {
            label,
            rowspan: rowspan || this.getMaxRows(children),
          };
          grids--;
        }

        for (const subItem of this.getFullChild(item.children)) {
          const { prop, children } = subItem;
          if (prop) {
            const tds = [];
            if (preLabel) {
              tds.push(preLabel);
              preLabel = null;
            }
            tds.push(subItem);
            result.push(tds);
          } else if (children) {
            result.push(...this.toFlat(subItem, grids));
          } else {
            result.push(null);
          }
        }
        return result;
      },
      mergeItem(foldTds) {
        const maxRow = Math.max(...foldTds.map((item) => item.length));
        const groupTds = [];

        for (let i = 0; i < maxRow; i++) {
          const rowTds = foldTds
            .map((item) => item[i])
            .filter(Boolean)
            .flat();
          groupTds.push(rowTds);
        }
        return groupTds;
      },
      // 自动计算栅格
      getAverageGrids(total, items) {
        let piece = items.length;
        const emptyIndexes = [];
        const baseGrids = items.map((item, index) => {
          if (item.colspan) {
            piece--;
            total = total - item.colspan - 1;
          } else {
            emptyIndexes.push(index);
          }
          return item.colspan;
        });
        if (piece > 0) {
          const unit = Math.floor(total / piece);
          const restNumbers = total % piece;
          for (let i = 0; i < piece; i++) {
            let curUnit = unit;
            if (i < restNumbers) {
              curUnit++;
            }
            const curEmptyInx = emptyIndexes[emptyIndexes.length - i - 1];
            baseGrids[curEmptyInx] = curUnit;
          }
        }
        return baseGrids;
      },
      getFullChild(children) {
        return children.reduce((pre, cur) => {
          if (cur.prop && cur.rowspan) {
            return pre.concat(cur, ...new Array(cur.rowspan - 1).fill({}));
          }
          return pre.concat(cur);
        }, []);
      },
      getMaxRows(srcList = [], account = 0) {
        for (const item of srcList) {
          account++;
          if (item.children?.length) {
            return this.getMaxRows(item.children, account);
          }
        }
        return account;
      },
    })

    // 
    const tds = data.map(item => toFlat(item));
    const newData = mergeItem(tds);
    console.log(newData);
  </script>
</body>

</html>